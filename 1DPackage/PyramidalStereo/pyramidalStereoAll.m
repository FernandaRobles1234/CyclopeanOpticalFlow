(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
move[im_,dx_]:=ImagePerspectiveTransformation[im,TranslationTransform[{dx,0}],DataRange->Full,Padding->"Reflected"]
showMove[ia_,ib_,{lowdx_,highdx_}]:=Manipulate[Show[Abs[ia-move[ib,dx]], ImageSize->Medium],{dx,lowdx,highdx}];

move::usage="
Input-> [im, dx]
Output -> image deplaced by dx
";

showMove::usage="
Input->[ia, ib, {lowdx, highdx}]
Output-> Manipulate object deplacing ia in range of lowdx and highdx with static ib
";


(* ::Input::Initialization:: *)
stereoDepth[ia_,ib_,lvl_,{lvlmin_,lvlmax_},rangex_,rangey_,threshold_, mode_]:=Block[{ka,kb,pyra,pyrb,pyrab,thresholdAdj,dd,e,v1,v2},
thresholdAdj=threshold*2^(-lvlmin+1);

Get["pyramidalCyclope1DLK"<>mode<>"`"];

Table[

{ka,kb}=ImageData[#][[k]]&/@{ia,ib};
pyra=pyrFuncGen[ka,lvl];
pyrb=pyrFuncGen[kb,lvl];
pyrab=Flatten[{pyra, pyrb},{{2},{1},{3}}];

Table[
If[mode=="OverConstrained",{v1,v2,dd}=PyrFlow1D[10,x,pyrab[[lvlmin;;lvlmax]],thresholdAdj],If[mode=="SemiConstrained",{v1,v2,dd}=PyrFlow1D[10,x,pyrab[[lvlmin;;lvlmax]],thresholdAdj],{v1,v2,dd,e}=PyrFlow1D[10,x,pyrab[[lvlmin;;lvlmax]],thresholdAdj]]];


{Total[{v1,v2}],dd,v1,v2}
,{x,rangex}]

,{k, rangey}]
]

stereoDepth[ia_,ib_,lvl_,mode_]:=stereoDepth[ia,ib,lvl,{1,lvl},Range[1,ImageDimensions[ia][[1]],1],Range[1,ImageDimensions[ia][[2]],1],0.0001,mode]
stereoDepth[ia_,ib_,lvl_,{lvlmin_,lvlmax_},threshold_,mode_]:=stereoDepth[ia,ib,lvl,{lvlmin,lvlmax},Range[1,ImageDimensions[ia][[1]],1],Range[1,ImageDimensions[ia][[2]],1],threshold,mode]

stereoDepth::usage="
Input=[ia, ib, lvl,{lvlmin,lvlmax},threshold, mode]
Output= {v, status, v1, v2}
ia= image a
ib= image b
lvl= max lvls to compute 
threshold= threshold for magnitude constraint
mode= method to calculate optical flow
";



